# 系统性调研报告与修复方案

经过对代码库的深度排查和逻辑验证，我找到了您遇到的“刷新后本地存储丢失”以及“数据死而复生”问题的根本原因。这并非数据真的“丢失”了，而是**初始化逻辑误判**与**软删除机制**相互作用导致的“隐形”状态。

## 🔍 问题根源分析

### 1. “本地存储丢失”的假象
*   **现象**：刷新页面后，列表显示为空。
*   **原因**：
    *   当您删除单词时，我们执行了“软删除”（`isDeleted: true`），单词仍在本地存储中，只是被标记了。
    *   `dashboard.js` 的初始化代码 (`init`) 会检查本地是否有数据。
    *   **Bug 所在**：旧的检查逻辑 `Object.keys(savedWords).length === 0` 只看“有没有数据”，不看“是不是已删除的数据”。
    *   **结果**：初始化程序发现“有数据”（虽然都是已删除的），因此判断不需要从云端拉取 (`PULL`)。随后渲染列表时，又自动过滤掉了已删除的单词。
    *   **最终效果**：您看到一个空的列表，误以为数据丢了。

### 2. “死而复生”的循环
*   **现象**：手动点击同步后，数据又回来了。
*   **原因**：
    *   因为自动同步被跳过，您只能手动点击同步。
    *   手动同步触发 `PULL` 操作，从云端下载备份。
    *   如果云端的备份（可能由于之前的并发问题）仍然保留着“未删除”的状态，且时间戳处理稍有偏差，云端数据就会覆盖本地的“软删除”状态，导致单词复活。

### 3. 并发冲突 (Race Condition)
*   **现象**：操作不稳定，有时删不掉。
*   **原因**：Chrome 扩展的后台服务是异步的。快速的“保存/删除”操作和“自动同步”操作可能同时读写数据，导致覆盖。
*   **修复**：我在后台引入了 `Mutex`（互斥锁）机制，强制所有读写操作排队执行，确保数据一致性。

---

## 🛠️ 修复与实施计划

我将执行以下修改来彻底解决问题：

### 第一步：修复 Dashboard 初始化逻辑 (`src/dashboard/dashboard.js`)
*   **逻辑升级**：在判断“是否为空”时，增加对 `isDeleted` 的过滤。只有当**有效单词数量为 0** 时，才视为初始化状态。
*   **用户体验**：当检测到本地为空时，在界面上明确显示 **“正在检查云端备份...”**，避免给用户造成“数据丢失”的恐慌。
*   **代码清理**：移除无效的 `CHECK_ONLY` 逻辑。

### 第二步：确认互斥锁机制 (`src/background/service-worker.js`)
*   **再次核实**：确保 `Mutex` 锁机制已正确应用在 `handleSaveWord`（保存）、`handleRemoveWord`（删除）和 `handleSyncData`（同步）的所有关键路径上。

### 第三步：验证
*   **预期行为**：
    1.  删除单词 -> 列表消失 -> 后台自动推送到云端。
    2.  刷新页面 -> 初始化检测到只有删除的数据 -> 视为“空” -> 自动触发云端拉取（双重保险）。
    3.  列表保持为空（或显示云端带来的新数据），不会出现“诈尸”或“假空”现象。

准备好后，请批准执行此计划。